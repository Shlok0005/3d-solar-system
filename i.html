<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Simulation - Ultra Enhanced</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Inter', sans-serif; /* Use Inter font */
            background-color: #000; /* Default Dark background for space */
            color: #fff; /* Default White text for controls */
            display: flex;
            flex-direction: column; /* Stack controls and canvas vertically */
            min-height: 100vh;
            transition: background-color 0.5s ease; /* Smooth transition for theme change */
        }

        body.light-theme {
            background-color: #e0e0e0;
            color: #333;
        }

        #canvas-container {
            flex-grow: 1; /* Allow canvas to take available height */
            position: relative;
            width: 100%;
            height: calc(100vh - 200px); /* Adjust height for controls */
            overflow: hidden;
            cursor: grab; /* Default cursor for camera movement */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #controls-panel {
            background-color: #1a1a1a;
            padding: 1rem;
            border-top: 1px solid #333;
            max-height: 200px; /* Max height for controls */
            overflow-y: auto; /* Enable scrolling for controls if needed */
            width: 100%;
            box-sizing: border-box; /* Include padding in width calculation */
            border-radius: 0.5rem 0.5rem 0 0; /* Rounded top corners */
            transition: background-color 0.5s ease, border-color 0.5s ease; /* Smooth transition for theme change */
        }

        body.light-theme #controls-panel {
            background-color: #f0f0f0;
            border-top-color: #ccc;
            color: #333;
        }

        .planet-control {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
            gap: 1rem;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .planet-control label {
            width: 80px; /* Fixed width for labels */
            flex-shrink: 0;
            color: #bbb;
        }

        body.light-theme .planet-control label {
            color: #555;
        }

        .planet-control input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            opacity: 0.7;
            transition: opacity .15s ease-in-out;
            border-radius: 4px;
        }
        body.light-theme .planet-control input[type="range"] {
             background: #aaa;
        }


        .planet-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .planet-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .speed-value {
            min-width: 30px;
            text-align: right;
            font-size: 0.9em;
            color: #999;
        }
        body.light-theme .speed-value {
            color: #777;
        }

        button {
            background-color: #0d6efd;
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        button:hover {
            background-color: #0b5ed7;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        body.light-theme button:not(#reset-speeds-btn) { /* Apply to all except reset button */
            background-color: #0d6efd; /* Keep blue for consistency or change as desired */
            color: white;
        }
        body.light-theme button:not(#reset-speeds-btn):hover {
            background-color: #0b5ed7;
        }
        body.light-theme #reset-speeds-btn {
            background-color: #dc3545; /* Red for reset */
        }
        body.light-theme #reset-speeds-btn:hover {
            background-color: #c82333;
        }
        body.light-theme #reset-camera-btn {
            background-color: #6c757d; /* Grey for reset camera */
        }
        body.light-theme #reset-camera-btn:hover {
            background-color: #5a6268;
        }
         body.light-theme #toggle-orbits-btn, body.light-theme #dark-light-toggle-btn {
            background-color: #4CAF50; /* Green for new buttons in light mode */
            color: white;
        }
        body.light-theme #toggle-orbits-btn:hover, body.light-theme #dark-light-toggle-btn:hover {
            background-color: #45a049;
        }


        /* Tooltip styles */
        #planet-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            pointer-events: none; /* Allows clicks to pass through to canvas */
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            transform: translate(-50%, -100%); /* Center horizontally, push up vertically */
            z-index: 10; /* Ensure it's above the canvas */
            white-space: nowrap; /* Prevent text wrapping */
        }

        #planet-tooltip.visible {
            opacity: 1;
        }

        /* Info Panel Styles */
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(26, 26, 26, 0.8); /* Semi-transparent dark background */
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            z-index: 10;
            max-width: 250px;
            pointer-events: none; /* Allow interaction with canvas below */
            opacity: 0;
            transition: opacity 0.3s ease-in-out, background-color 0.5s ease;
        }

        #info-panel.visible {
            opacity: 1;
            pointer-events: auto; /* Allow interaction with panel when visible */
        }

        body.light-theme #info-panel {
            background-color: rgba(240, 240, 240, 0.8);
            color: #333;
        }

        #info-panel h3 {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: #4CAF50; /* Highlight planet name */
        }
        body.light-theme #info-panel h3 {
             color: #0d6efd;
        }


        @media (max-width: 768px) {
            #controls-panel {
                max-height: 250px; /* More height for controls on smaller screens */
            }
            .planet-control {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            .planet-control label {
                width: auto; /* Auto width for labels */
                margin-bottom: 0.25rem;
            }
            #info-panel {
                left: 0.5rem;
                right: 0.5rem;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="planet-tooltip" class="hidden"></div>
        <div id="info-panel" class="hidden">
            <h3 id="info-panel-name"></h3>
            <p><strong>Radius:</strong> <span id="info-panel-radius"></span> units</p>
            <p><strong>Distance from Sun:</strong> <span id="info-panel-distance"></span> units</p>
        </div>
    </div>
    <div id="controls-panel" class="p-4 shadow-lg">
        <div class="flex flex-wrap justify-center gap-4 mb-4">
            <button id="pause-resume-btn" class="px-6 py-3 rounded-lg">Pause</button>
            <button id="reset-speeds-btn" class="px-6 py-3 bg-red-600 rounded-lg hover:bg-red-700">Reset Speeds</button>
            <button id="reset-camera-btn" class="px-6 py-3 bg-gray-700 rounded-lg hover:bg-gray-600">Reset Camera</button>
            <button id="toggle-orbits-btn" class="px-6 py-3 bg-green-600 rounded-lg hover:bg-green-700">Hide Orbits</button>
            <button id="dark-light-toggle-btn" class="px-6 py-3 bg-indigo-600 rounded-lg hover:bg-indigo-700">Light Mode</button>
        </div>
        <div id="planet-sliders" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            <!-- Planet sliders will be dynamically generated here -->
        </div>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls CDN for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>


    <script>
        // Ensure OrbitControls is attached to THREE (compatibility fallback)
        if (typeof THREE !== 'undefined' && typeof OrbitControls !== 'undefined' && typeof THREE.OrbitControls === 'undefined') {
            THREE.OrbitControls = OrbitControls;
            console.log("OrbitControls manually attached to THREE namespace.");
        } else if (typeof THREE !== 'undefined' && typeof THREE.OrbitControls === 'function') {
            console.log("THREE.OrbitControls already exists and is a function.");
        } else {
            console.warn("Could not confirm THREE.OrbitControls is set up after loading OrbitControls.js. Check console for deeper errors.");
        }
        console.log("State of THREE.OrbitControls before init:", typeof THREE !== 'undefined' ? THREE.OrbitControls : "THREE is undefined");
        console.log("State of window.OrbitControls before init:", typeof window.OrbitControls);
    </script>

    <script>
        // Basic Three.js setup: scene, camera, renderer
        let scene, camera, renderer, controls;
        let sun;
        const planets = []; // Array to hold planet objects and their orbital properties
        const orbitLines = []; // Array to hold orbit line objects
        let isPaused = false;
        let showOrbits = true;
        let isLightMode = false;
        const clock = new THREE.Clock(); // For consistent animation timing

        const raycaster = new THREE.Raycaster(); // For hover and click detection
        const mouse = new THREE.Vector2(); // Mouse coordinates
        let tooltip = document.getElementById('planet-tooltip');
        let infoPanel = document.getElementById('info-panel');
        let hoveredPlanet = null;
        let focusedPlanet = null; // Stores the planet currently being focused by the camera

        // Initial camera position for reset (adjusted for larger system scale)
        // Significantly increased Z to pull camera further back to see ALL orbits and stars
        const initialCameraPosition = new THREE.Vector3(0, 30000, 100000); // Drastically increased Z and Y
        const initialControlsTarget = new THREE.Vector3(0, 0, 0);


        // Constants for scaling and speeds (adjust as needed for visual appeal)
        const ORBIT_SCALE = 80; // Multiplier for orbital distances (increased for better spacing)
        const PLANET_SIZE_SCALE = 35.0; // Multiplier for planet radii (TRULY COLOSSAL for ultimate visibility)
        const INITIAL_ORBITAL_SPEED_FACTOR = 0.001; // Base speed for all planets (increased for more visible movement)
        const AXIAL_ROTATION_SPEED_FACTOR = 0.01; // Speed for axial rotation (increased for more visible spin)
        const CAMERA_ZOOM_FACTOR = 3; // Adjusted for good close-up with larger planets - allows closer zoom

        // Data for celestial bodies with distinct fallback colors
        const celestialBodiesData = [
            // Sun's radius adjusted to be significantly larger than all planets
            { name: "Sun", radius: 15.0, color: 0xFDB813, distance: 0, initialSpeed: 0, selfRotation: true, type: "star", fallbackColor: 0xFDB813 }, // Sun is now largest
            // Increased distances for inner planets to create bigger gaps
            { name: "Mercury", radius: 0.38, color: 0xBCBCBC, distance: 15, initialSpeed: 4.0, selfRotation: true, fallbackColor: 0x9e9e9e },
            { name: "Venus", radius: 0.95, color: 0xE2C58F, distance: 25, initialSpeed: 1.6, selfRotation: true, fallbackColor: 0xffa500 },
            { name: "Earth", radius: 1, color: 0x2E8B57, distance: 35, initialSpeed: 1.0, selfRotation: true, fallbackColor: 0x008000 },
            { name: "Mars", radius: 0.53, color: 0xC1440E, distance: 45, initialSpeed: 0.8, selfRotation: true, fallbackColor: 0xcc5500 },
            { name: "Jupiter", radius: 11.2, color: 0xA08668, distance: 80, initialSpeed: 0.2, selfRotation: true, fallbackColor: 0xccaa88 },
            { name: "Saturn", radius: 9.45, color: 0xD0C49F, distance: 120, initialSpeed: 0.15, selfRotation: true, fallbackColor: 0xd9c29f, hasRings: true },
            { name: "Uranus", radius: 4, color: 0xADD8E6, distance: 220, initialSpeed: 0.07, selfRotation: true, fallbackColor: 0x87ceeb },
            { name: "Neptune", radius: 3.88, color: 0x4169E1, distance: 350, initialSpeed: 0.05, selfRotation: true, fallbackColor: 0x4169e1 }
        ];

        // Function to generate a canvas texture (solid color with optional pattern/text)
        function generateCanvasTexture(color, name, width = 256, height = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');

            const hexColor = '#' + color.toString(16).padStart(6, '0');
            context.fillStyle = hexColor;
            context.fillRect(0, 0, width, height);

            // Add subtle patterns for planets
            if (name === "Sun") {
                const gradient = context.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width / 2);
                gradient.addColorStop(0, 'rgba(255, 255, 100, 1)'); // Brighter center, more yellow
                gradient.addColorStop(0.3, 'rgba(255, 190, 0, 1)'); // More orange
                gradient.addColorStop(0.7, 'rgba(255, 100, 0, 1)'); // Deeper orange
                gradient.addColorStop(1, 'rgba(255, 30, 0, 0.9)'); // Reddish orange at edges, higher opacity
                context.fillStyle = gradient;
                context.fillRect(0, 0, width, height);
            } else if (name === "Jupiter") {
                // Bands for Jupiter - More distinct
                const bandColors = ['#E6C8A6', '#B0967A', '#D9BBA3', '#8C7461', '#E6C8A6']; // Earthy tones
                const bandHeight = height / bandColors.length;
                for (let i = 0; i < bandColors.length; i++) {
                    context.fillStyle = bandColors[i];
                    context.fillRect(0, i * bandHeight, width, bandHeight);
                }
            } else if (name === "Saturn") {
                // Subtle banding for Saturn - More distinct
                const bandColors = ['#F2E0C4', '#DCC9A9', '#F2E0C4']; // Lighter, creamy tones
                const bandHeight = height / bandColors.length;
                for (let i = 0; i < bandColors.length; i++) {
                    context.fillStyle = bandColors[i];
                    context.fillRect(0, i * bandHeight, width, bandHeight);
                }
            } else if (name === "Earth") {
                // Earth-like pattern with blues and greens
                context.fillStyle = '#4CAF50'; // Green land
                context.fillRect(0, 0, width, height);
                context.fillStyle = '#0d6efd'; // Blue ocean
                context.beginPath();
                context.arc(width * 0.3, height * 0.7, width * 0.4, 0, Math.PI * 2);
                context.arc(width * 0.7, height * 0.2, width * 0.3, 0, Math.PI * 2);
                context.fill();
            } else {
                // Generic subtle noise/gradient for other planets
                const gradient = context.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, `rgba(${parseInt(hexColor.substring(1,3), 16) * 0.7}, ${parseInt(hexColor.substring(3,5), 16) * 0.7}, ${parseInt(hexColor.substring(5,7), 16) * 0.7}, 1)`); // Darker start
                gradient.addColorStop(1, hexColor); // Original color end
                context.fillStyle = gradient;
                context.fillRect(0, 0, width, height);

                // Add subtle noise for texture
                for (let i = 0; i < 900; i++) { // Even more noise for more textured look
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const alpha = Math.random() * 0.2; // Slightly more visible noise
                    context.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    context.fillRect(x, y, 1, 1);
                }
            }

            return new THREE.CanvasTexture(canvas);
        }

        // Function to generate a canvas texture for Saturn's rings
        function generateRingTexture(innerRadius, outerRadius, width = 512, height = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');

            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.max(innerRadius, outerRadius);
            const scale = Math.min(width, height) / (2 * maxRadius * 1.1);

            context.clearRect(0, 0, width, height);

            // Draw a base translucent ring
            context.beginPath();
            context.arc(centerX, centerY, outerRadius * scale, 0, Math.PI * 2);
            context.arc(centerX, centerY, innerRadius * scale, 0, Math.PI * 2, true);
            context.fillStyle = 'rgba(200, 200, 200, 0.85)'; // Brighter grey, higher opacity for base
            context.fill();

            // Add thin, brighter lines for a textured effect
            for (let i = 0; i < 300; i++) { // More lines for denser texture
                const r = Math.random() * (outerRadius - innerRadius) + innerRadius;
                const angle = Math.random() * Math.PI * 2;
                const x1 = centerX + Math.cos(angle) * r * scale;
                const y1 = centerY + Math.sin(angle) * r * scale;
                const x2 = centerX + Math.cos(angle + 0.02) * r * scale; // Even narrower lines
                const y2 = centerY + Math.sin(angle + 0.02) * r * scale;
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.strokeStyle = `rgba(240, 240, 240, ${0.5 + Math.random() * 0.4})`; // Even brighter lines, higher opacity
                context.lineWidth = 1 + Math.random() * 0.5; // Thinner lines
                context.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }


        // Function to initialize the Three.js scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Black background for space

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 200), 0.1, 100000); // Increased far clipping plane
            camera.position.copy(initialCameraPosition); // Set initial camera position
            camera.lookAt(initialControlsTarget); // Make camera look at target

            // Renderer
            const canvasContainer = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            canvasContainer.appendChild(renderer.domElement);

            // Controls (for camera movement)
            if (typeof THREE.OrbitControls === 'function') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                console.log("Using THREE.OrbitControls for camera controls.");
            } else if (typeof window.OrbitControls === 'function') {
                controls = new window.OrbitControls(camera, renderer.domElement);
                console.log("Using window.OrbitControls for camera controls (fallback).");
            } else {
                console.error("Critical Error: OrbitControls constructor is still not found. Cannot initialize camera controls. Please check network connection and script loading.");
                return;
            }

            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Limit panning
            controls.maxDistance = 120000; // Increased max zoom out significantly to accommodate larger system
            controls.minDistance = 5; // Decreased min zoom in for much closer view (was 1, but 5 is a good balance for larger planets)
            controls.target.copy(initialControlsTarget); // Set initial controls target

            // Lighting
            // Ambient light to dimly illuminate all objects (increased intensity)
            const ambientLight = new THREE.AmbientLight(0xB0B0B0); // Increased ambient light for overall brightness
            scene.add(ambientLight);

            // Point light for the Sun (illuminates other objects - increased intensity)
            const sunLight = new THREE.PointLight(0xFFFFFF, 8.0, 0, 2); // Increased intensity to 8.0 for maximum vibrancy
            sunLight.position.set(0, 0, 0);
            scene.add(sunLight);

            // Add stars to the background
            createStars();

            // Create celestial bodies
            createCelestialBodies();

            // Setup control panel
            setupControlPanel();

            // Event Listeners for interactive features
            window.addEventListener('resize', onWindowResize);
            canvasContainer.addEventListener('mousemove', onMouseMove);
            canvasContainer.addEventListener('click', onClick);

            // Initialize tooltip and info panel state
            tooltip.classList.add('hidden');
            infoPanel.classList.add('hidden');
        }

        // Function to create stars for the background
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 4.0, sizeAttenuation: true }); // Increased star size further

            const starVertices = [];
            // Increased the spread of stars to fill the larger view
            for (let i = 0; i < 30000; i++) { // Significantly increased number of stars for denser field
                const x = THREE.MathUtils.randFloatSpread(150000); // Increased spread even further
                const y = THREE.MathUtils.randFloatSpread(150000); // Increased spread even further
                const z = THREE.MathUtils.randFloatSpread(150000); // Increased spread even further
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // Function to create the Sun and planets using dynamically generated textures
        function createCelestialBodies() {
            celestialBodiesData.forEach(data => {
                const geometry = new THREE.SphereGeometry(data.radius * PLANET_SIZE_SCALE, 32, 32);
                let material;
                let planetTexture = generateCanvasTexture(data.fallbackColor, data.name);


                if (data.type === "star") {
                    material = new THREE.MeshBasicMaterial({
                        map: planetTexture,
                        color: 0xFFFFFF,
                        emissive: new THREE.Color(data.color),
                        emissiveIntensity: 20 // Increased intensity to 20 for an even brighter glow
                    });
                    sun = new THREE.Mesh(geometry, material);
                    sun.userData.name = data.name;
                    sun.userData.type = data.type;
                    sun.userData.radius = data.radius * PLANET_SIZE_SCALE;
                    sun.userData.distance = data.distance * ORBIT_SCALE;
                    scene.add(sun);
                } else {
                    // KEY CHANGE: Set MeshStandardMaterial color to a darker grey to prevent texture wash-out near bright lights
                    material = new THREE.MeshStandardMaterial({
                        map: planetTexture,
                        color: 0x505050 // Changed from 0xFFFFFF to a darker grey to allow texture to dominate
                    });
                    const planetMesh = new THREE.Mesh(geometry, material);
                    planetMesh.userData.name = data.name;
                    planetMesh.userData.type = "planet";
                    planetMesh.userData.radius = data.radius * PLANET_SIZE_SCALE;
                    planetMesh.userData.distance = data.distance * ORBIT_SCALE;


                    const orbitGroup = new THREE.Group();
                    orbitGroup.add(planetMesh);
                    scene.add(orbitGroup);

                    planetMesh.position.x = data.distance * ORBIT_SCALE;

                    planets.push({
                        name: data.name,
                        mesh: planetMesh,
                        orbitGroup: orbitGroup,
                        orbitalSpeed: data.initialSpeed * INITIAL_ORBITAL_SPEED_FACTOR,
                        axialRotationSpeed: data.selfRotation ? AXIAL_ROTATION_SPEED_FACTOR : 0,
                        data: data
                    });

                    // Add Saturn's rings (Bonus Feature)
                    if (data.name === "Saturn" && data.hasRings) {
                        const ringGeometry = new THREE.RingGeometry(
                            data.radius * PLANET_SIZE_SCALE * 1.5, // Inner radius
                            data.radius * PLANET_SIZE_SCALE * 2.5, // Outer radius
                            64
                        );
                        const ringTexture = generateRingTexture(data.radius * PLANET_SIZE_SCALE * 1.5, data.radius * PLANET_SIZE_SCALE * 2.5);
                        const ringMaterial = new THREE.MeshBasicMaterial({
                            map: ringTexture,
                            side: THREE.DoubleSide,
                            transparent: true,
                            alphaMap: ringTexture,
                            opacity: 0.999 // Increased opacity for maximum visibility
                        });
                        const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                        ringMesh.rotation.x = Math.PI / 2;
                        planetMesh.add(ringMesh); // Add ring as a child of Saturn's mesh
                    }

                    // Create orbit line for planets
                    if (data.distance > 0) {
                        // Increased orbit thickness and opacity for distinct visibility
                        const orbitThickness = 40; // SIGNIFICANTLY Increased thickness
                        const orbitGeometry = new THREE.RingGeometry(data.distance * ORBIT_SCALE - orbitThickness / 2, data.distance * ORBIT_SCALE + orbitThickness / 2, 128);
                        const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.99 }); // Pure white color and very high opacity for orbits
                        const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                        orbit.rotation.x = Math.PI / 2;
                        scene.add(orbit);
                        orbitLines.push(orbit);
                    }
                }
            });
        }

        // Function to set up the control panel with sliders
        function setupControlPanel() {
            const planetSlidersContainer = document.getElementById('planet-sliders');
            planets.forEach(planet => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'planet-control';

                const label = document.createElement('label');
                label.textContent = planet.name;
                label.htmlFor = `slider-${planet.name}`;
                controlDiv.appendChild(label);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = `slider-${planet.name}`;
                slider.min = 0.01;
                slider.max = 8;
                slider.step = 0.01;
                slider.value = planet.orbitalSpeed / INITIAL_ORBITAL_SPEED_FACTOR;

                const speedValueSpan = document.createElement('span');
                speedValueSpan.className = 'speed-value';
                speedValueSpan.textContent = slider.value;

                slider.addEventListener('input', (event) => {
                    planet.orbitalSpeed = parseFloat(event.target.value) * INITIAL_ORBITAL_SPEED_FACTOR;
                    speedValueSpan.textContent = event.target.value;
                });

                controlDiv.appendChild(slider);
                controlDiv.appendChild(speedValueSpan);
                planetSlidersContainer.appendChild(controlDiv);
            });

            // Pause/Resume button
            const pauseResumeBtn = document.getElementById('pause-resume-btn');
            pauseResumeBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                pauseResumeBtn.textContent = isPaused ? 'Resume' : 'Pause';
            });

            // Reset Speeds button
            const resetSpeedsBtn = document.getElementById('reset-speeds-btn');
            resetSpeedsBtn.addEventListener('click', () => {
                planets.forEach(planet => {
                    const initialData = celestialBodiesData.find(d => d.name === planet.name);
                    if (initialData) {
                        planet.orbitalSpeed = initialData.initialSpeed * INITIAL_ORBITAL_SPEED_FACTOR;
                        const slider = document.getElementById(`slider-${planet.name}`);
                        if (slider) {
                            slider.value = initialData.initialSpeed;
                            slider.nextElementSibling.textContent = initialData.initialSpeed;
                        }
                    }
                });
            });

            // Reset Camera button
            const resetCameraBtn = document.getElementById('reset-camera-btn');
            resetCameraBtn.addEventListener('click', () => {
                focusedPlanet = null; // Unfocus any planet
                infoPanel.classList.remove('visible');
                infoPanel.classList.add('hidden');

                gsap.to(camera.position, {
                    x: initialCameraPosition.x,
                    y: initialCameraPosition.y,
                    z: initialCameraPosition.z,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => controls.update()
                });
                gsap.to(controls.target, {
                    x: initialControlsTarget.x,
                    y: initialControlsTarget.y,
                    z: initialControlsTarget.z,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => controls.update()
                });
            });

            // Toggle Orbits button
            const toggleOrbitsBtn = document.getElementById('toggle-orbits-btn');
            toggleOrbitsBtn.addEventListener('click', () => {
                showOrbits = !showOrbits;
                orbitLines.forEach(line => {
                    line.visible = showOrbits;
                });
                toggleOrbitsBtn.textContent = showOrbits ? 'Hide Orbits' : 'Show Orbits';
            });

            // Dark/Light Mode Toggle button
            const darkLightToggleBtn = document.getElementById('dark-light-toggle-btn');
            darkLightToggleBtn.addEventListener('click', () => {
                isLightMode = !isLightMode;
                document.body.classList.toggle('light-theme', isLightMode);

                if (isLightMode) {
                    scene.background = new THREE.Color(0xe0e0e0); // Light background
                    // You might want to adjust ambient light or Sun light intensity for light mode too
                } else {
                    scene.background = new THREE.Color(0x000000); // Dark background
                }
                darkLightToggleBtn.textContent = isLightMode ? 'Dark Mode' : 'Light Mode';
            });
        }

        // Event handler for mouse movement (for tooltips)
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            const canvasRect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
            mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the raycaster
            const interactableObjects = planets.map(p => p.mesh);
            if (sun) {
                interactableObjects.push(sun);
            }
            const intersects = raycaster.intersectObjects(interactableObjects);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.name) {
                    if (hoveredPlanet !== object) {
                        hoveredPlanet = object;
                        tooltip.textContent = object.userData.name;
                        tooltip.classList.remove('hidden');
                        tooltip.classList.add('visible');
                    }
                    // Update tooltip position relative to canvas container
                    const vector = object.position.clone().project(camera);
                    const x = (vector.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
                    const y = (-vector.y * 0.5 + 0.5) * canvasRect.height + canvasRect.top;
                    tooltip.style.left = `${x}px`;
                    tooltip.style.top = `${y}px`;
                }
            } else {
                if (hoveredPlanet !== null) {
                    hoveredPlanet = null;
                    tooltip.classList.remove('visible');
                    tooltip.classList.add('hidden');
                }
            }
        }

        // Event handler for mouse clicks (for zooming to planet and showing info)
        function onClick(event) {
            const canvasRect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
            mouse.y = -((event.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const interactableObjects = planets.map(p => p.mesh);
            if (sun) {
                interactableObjects.push(sun);
            }
            const intersects = raycaster.intersectObjects(interactableObjects);

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object;
                // Find the full planet data (including the original `data` object for info panel)
                const clickedPlanetData = planets.find(p => p.mesh === clickedMesh) || (clickedMesh === sun ? { name: sun.userData.name, mesh: sun, data: { radius: sun.userData.radius / PLANET_SIZE_SCALE, distance: sun.userData.distance / ORBIT_SCALE } } : null);

                if (clickedPlanetData) {
                    focusedPlanet = clickedPlanetData; // Set the focused planet
                    updateInfoPanel(focusedPlanet);

                    const targetObjectWorldPosition = new THREE.Vector3();
                    // Get world position of the mesh (if it's a planet, its in an orbit group)
                    if (clickedMesh.userData.type === "planet") {
                        clickedMesh.getWorldPosition(currentTargetPosition);
                    } else { // It's the sun
                        currentTargetPosition.copy(focusedPlanet.mesh.position);
                    }


                    // Calculate a good camera position to zoom to the clicked planet
                    // Use a slightly larger radius for the Sun to keep it fully in view
                    const objectRadius = clickedMesh.userData.radius;
                    // Adjusted zoom distance for even closer view
                    const zoomDistance = objectRadius * CAMERA_ZOOM_FACTOR + objectRadius * 2;
                    const currentCameraDirection = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    const newCameraPosition = targetObjectWorldPosition.clone().add(currentCameraDirection.multiplyScalar(zoomDistance));

                    // Animate camera position and controls target
                    gsap.to(camera.position, {
                        x: newCameraPosition.x,
                        y: newCameraPosition.y,
                        z: newCameraPosition.z,
                        duration: 1.5,
                        ease: "power2.inOut",
                        onUpdate: () => controls.update()
                    });
                    gsap.to(controls.target, {
                        x: targetObjectWorldPosition.x,
                        y: targetObjectWorldPosition.y,
                        z: targetObjectWorldPosition.z,
                        duration: 1.5,
                        ease: "power2.inOut",
                        onUpdate: () => controls.update()
                    });
                }
            } else {
                // If clicked outside of a planet, unfocus
                focusedPlanet = null;
                infoPanel.classList.remove('visible');
                infoPanel.classList.add('hidden');
            }
        }

        // Function to update the info panel
        function updateInfoPanel(planet) {
            document.getElementById('info-panel-name').textContent = planet.name;
            // Display actual radius and distance from original data for clarity
            document.getElementById('info-panel-radius').textContent = planet.data.radius.toFixed(2);
            document.getElementById('info-panel-distance').textContent = planet.data.distance.toFixed(2);
            infoPanel.classList.remove('hidden');
            infoPanel.classList.add('visible');
        }


        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (controls) {
                // If a planet is focused, update controls target to follow its current world position
                if (focusedPlanet) {
                    const currentTargetPosition = new THREE.Vector3();
                    if (focusedPlanet.mesh.userData.type === "planet") {
                        focusedPlanet.mesh.getWorldPosition(currentTargetPosition);
                    } else { // It's the sun
                        currentTargetPosition.copy(focusedPlanet.mesh.position);
                    }
                    controls.target.copy(currentTargetPosition);
                }
                controls.update();
            }

            if (!isPaused) {
                const delta = clock.getDelta();

                planets.forEach(planet => {
                    planet.orbitGroup.rotation.y += planet.orbitalSpeed * delta * 100;
                    planet.mesh.rotation.y += planet.axialRotationSpeed * delta * 100;
                });

                if (sun) {
                    sun.rotation.y += AXIAL_ROTATION_SPEED_FACTOR * delta * 100 * 0.2;
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resizing
        function onWindowResize() {
            const canvasContainer = document.getElementById('canvas-container');
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

        // Initialize the scene when the window loads
        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
